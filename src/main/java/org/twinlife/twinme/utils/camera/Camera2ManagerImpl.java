/*
 *  Copyright (c) 2021-2024 twinlife SA.
 *  SPDX-License-Identifier: AGPL-3.0-only
 *
 *  Contributors:
 *   Christian Jacquemot (Christian.Jacquemot@twinlife-systems.com)
 *   Stephane Carrez (Stephane.Carrez@twin.life)
 *   Fabrice Trescartes (Fabrice.Trescartes@twin.life)
 */

package org.twinlife.twinme.utils.camera;

import android.Manifest;
import android.app.Activity;
import android.content.Context;
import android.content.pm.PackageManager;
import android.graphics.ImageFormat;
import android.graphics.Rect;
import android.graphics.SurfaceTexture;
import android.hardware.camera2.CameraAccessException;
import android.hardware.camera2.CameraCaptureSession;
import android.hardware.camera2.CameraCharacteristics;
import android.hardware.camera2.CameraDevice;
import android.hardware.camera2.CameraManager;
import android.hardware.camera2.CameraMetadata;
import android.hardware.camera2.CaptureFailure;
import android.hardware.camera2.CaptureRequest;
import android.hardware.camera2.CaptureResult;
import android.hardware.camera2.TotalCaptureResult;
import android.hardware.camera2.params.StreamConfigurationMap;
import android.media.Image;
import android.media.ImageReader;
import android.util.Log;
import android.util.Range;
import android.view.Display;
import android.view.Surface;
import android.view.TextureView;

import androidx.annotation.NonNull;
import androidx.annotation.Nullable;
import androidx.core.content.ContextCompat;
import androidx.core.math.MathUtils;

import org.webrtc.Size;

import java.nio.ByteBuffer;
import java.util.ArrayList;
import java.util.List;

/**
 * Camera manager using the Android camera 2 API.
 */
public class Camera2ManagerImpl extends AbstractCameraManager implements ImageReader.OnImageAvailableListener {
    private static final String LOG_TAG = "Camera2ManagerImpl";
    private static final boolean TRACE = false;
    private static final boolean DEBUG = false;

    /**
     * Max preview width that is guaranteed by Camera2 API
     */
    private static final int MAX_PREVIEW_WIDTH = 1920;

    /**
     * Max preview height that is guaranteed by Camera2 API
     */
    private static final int MAX_PREVIEW_HEIGHT = 1080;

    /**
     * Max number of times we can retry opening the camera 2.
     */
    private static final int MAX_OPEN_RETRY = 2;

    /**
     * Minimum time between two frames delivered to onPicture() callback in milliseconds.
     * When onImageAvailable() gets more frames, they are dropped.  If we deliver too many
     * frames, the CameraThread does not have time to process other requests.
     * 250ms = 4fps which is enough for QR-code scanning.
     */
    private static final long MIN_FRAME_DELAY = 250;

    /**
     * In QR-Code scanning mode, retry autofocus after 5s if it failed.
     */
    private static final long MIN_AUTOFOCUS_DELAY = 5000;
    private static final long MIN_AUTOFOCUS_REFOCUS_DELAY = 1000;

    private final CameraManager mCameraManager;
    @Nullable
    private CameraDevice mCamera;
    @Nullable
    private Size mPreviewSize;
    private String mCameraId;
    private boolean mFlashSupported;
    private Rect mActiveArraySize;
    private Float mMaximumZoomLevel;
    @Nullable
    private CameraCaptureSession mCaptureSession;
    @Nullable
    private int[] mAutoExposureModes;
    @Nullable
    private int[] mAutoFocusModes;
    @Nullable
    private Range<Integer> mFpsRange;
    private Surface mPreviewSurface;
    private int mSensorOrientation;
    private int mOpenRetryCount;

    /**
     * An {@link ImageReader} that handles still image capture.
     */
    private ImageReader mImageReader;

    /**
     * {@link CaptureRequest.Builder} for the camera preview
     */
    private CaptureRequest.Builder mPreviewRequestBuilder;

    /**
     * {@link CaptureRequest} generated by {@link #mPreviewRequestBuilder}
     */
    private CaptureRequest mPreviewRequest;

    enum CameraState {
        STATE_PREVIEW,
        STATE_WAITING_LOCK,
        STATE_WAITING_PRECAPTURE,
        STATE_WAITING_NON_PRECAPTURE,
        STATE_PICTURE_TAKEN
    }

    private CameraState mCameraState;
    private long mLastAutoFocusTime;
    private long mLastImageTime;

    /**
     * Capture callback used when taking a picture.
     */
    private final CameraCaptureSession.CaptureCallback mCaptureCallback = new CameraCaptureSession.CaptureCallback() {
        private void process(@NonNull CaptureResult result) {
            final Integer afState = result.get(CaptureResult.CONTROL_AF_STATE);
            final Integer aeState = result.get(CaptureResult.CONTROL_AE_STATE);
            final Integer awbState = result.get(CaptureResult.CONTROL_AWB_STATE);

            if (TRACE) {
                Log.e(LOG_TAG, "Frame " + result.getFrameNumber() + " afState=" + afState + " aeState=" + aeState
                        + " awbState=" + awbState + " lastAutoFocusTime=" + (System.currentTimeMillis() - mLastAutoFocusTime));
            }

            switch (mCameraState) {
                case STATE_PREVIEW: {
                    // If the focus is locked, restart it after the MIN_AUTOFOCUS_REFOCUS_DELAY:
                    // if we restart too quickly, it does not work on some devices.
                    if (afState != null && (afState == CaptureResult.CONTROL_AF_STATE_FOCUSED_LOCKED
                            || afState == CaptureResult.CONTROL_AF_STATE_NOT_FOCUSED_LOCKED)) {
                        if ((System.currentTimeMillis() - mLastAutoFocusTime) > MIN_AUTOFOCUS_REFOCUS_DELAY) {
                            restartAutoFocus(true);
                        }
                    } else if ((mMode == Mode.QRCODE) && (System.currentTimeMillis() - mLastAutoFocusTime) > MIN_AUTOFOCUS_DELAY) {
                        restartAutoFocus(true);
                    }
                    break;
                }

                case STATE_WAITING_LOCK: {

                    if (DEBUG) {
                        Log.e(LOG_TAG, "CaptureCallback (waiting lock) process afState=" + afState);
                    }
                    if (afState == null) {
                        captureStillPicture();
                    } else if (CaptureResult.CONTROL_AF_STATE_FOCUSED_LOCKED == afState ||
                            CaptureResult.CONTROL_AF_STATE_NOT_FOCUSED_LOCKED == afState) {
                        // CONTROL_AE_STATE can be null on some devices
                        if (aeState == null || aeState == CaptureResult.CONTROL_AE_STATE_CONVERGED) {
                            mCameraState = CameraState.STATE_PICTURE_TAKEN;
                            captureStillPicture();
                        } else {
                            runPrecaptureSequence();
                        }
                    }
                    break;
                }

                case STATE_WAITING_PRECAPTURE: {
                    // CONTROL_AE_STATE can be null on some devices
                    if (DEBUG) {
                        Log.e(LOG_TAG, "CaptureCallback (precapture) process aeState=" + aeState);
                    }

                    if (aeState == null ||
                            aeState == CaptureResult.CONTROL_AE_STATE_PRECAPTURE ||
                            aeState == CaptureRequest.CONTROL_AE_STATE_FLASH_REQUIRED) {
                        mCameraState = CameraState.STATE_WAITING_NON_PRECAPTURE;
                    }
                    break;
                }

                case STATE_WAITING_NON_PRECAPTURE: {
                    // CONTROL_AE_STATE can be null on some devices
                    if (DEBUG) {
                        Log.e(LOG_TAG, "CaptureCallback (non precapture) process aeState=" + aeState);
                    }

                    if (aeState == null || aeState != CaptureResult.CONTROL_AE_STATE_PRECAPTURE) {
                        mCameraState = CameraState.STATE_PICTURE_TAKEN;
                        captureStillPicture();
                    }
                    break;
                }
            }
        }

        @Override
        public void onCaptureProgressed(@NonNull CameraCaptureSession session,
                                        @NonNull CaptureRequest request,
                                        @NonNull CaptureResult partialResult) {
            process(partialResult);
        }

        @Override
        public void onCaptureCompleted(@NonNull CameraCaptureSession session,
                                       @NonNull CaptureRequest request,
                                       @NonNull TotalCaptureResult result) {
            process(result);
        }

        @Override
        public void onCaptureFailed(@NonNull CameraCaptureSession session, @NonNull CaptureRequest request, @NonNull CaptureFailure failure) {
            if (DEBUG) {
                Log.d(LOG_TAG, "onCaptureFailed reason=" + failure.getReason());
            }

            // If there is a capture failure, abort the repeating requests.
            // We should try to restart but any attempts I've made failed.
            // Stopping is necessary otherwise the Camera server loops in that state.
            try {
                //mCaptureSession.stopRepeating();
                //mCaptureSession.abortCaptures();

            } catch (Exception ignored) {

            }
        }
    };

    private final CameraDevice.StateCallback mStateCallback = new CameraDevice.StateCallback() {

        @Override
        public void onDisconnected(@NonNull CameraDevice camera) {

            checkIsOnCameraThread();

            if (mCamera == camera) {
                mState = State.ERROR;
                mCameraCallback.onCameraError(ErrorCode.NO_CAMERA);
            }
        }

        @Override
        public void onError(@NonNull CameraDevice camera, int errorCode) {

            checkIsOnCameraThread();

            Log.e(LOG_TAG, "Camera error " + getErrorDescription(errorCode));
        }

        @Override
        public void onOpened(@NonNull CameraDevice camera) {

            checkIsOnCameraThread();

            createCameraPreviewSession(camera);
        }

        @Override
        public void onClosed(@NonNull CameraDevice camera) {

            checkIsOnCameraThread();

            if (mState != State.STARTING) {
                // Release the camera thread: it will stop when it is no longer in use.
                mCameraThread.release();
            }
        }
    };

    private final CameraCaptureSession.StateCallback mCaptureStateCallback = new CameraCaptureSession.StateCallback() {

        @Override
        public void onConfigured(@NonNull CameraCaptureSession cameraCaptureSession) {
            // The camera is already closed
            if (null == mCamera) {
                return;
            }

            // When the session is ready, we start displaying the preview.
            mCaptureSession = cameraCaptureSession;
            try {
                // Auto focus should be continuous for camera preview.
                if (hasMode(mAutoExposureModes, CaptureRequest.CONTROL_AF_MODE_AUTO)) {
                    mPreviewRequestBuilder.set(CaptureRequest.CONTROL_AF_MODE, CaptureRequest.CONTROL_AF_MODE_AUTO);
                }

                mPreviewRequestBuilder.set(CaptureRequest.CONTROL_AE_LOCK, Boolean.FALSE);

                // Flash is automatically enabled when necessary.
                if (mMode != Mode.QRCODE) {
                    setAutoFlash(mPreviewRequestBuilder);
                }

                // Finally, we start displaying the camera preview.
                mPreviewRequest = mPreviewRequestBuilder.build();
                cameraCaptureSession.setRepeatingRequest(mPreviewRequest, mCaptureCallback, mCameraHandler);
            } catch (CameraAccessException e) {
                Log.e(LOG_TAG, "Camera configured error", e);

            } catch (RuntimeException ex) {
                Log.d(LOG_TAG, "exception", ex);
            }
        }

        @Override
        public void onConfigureFailed(@NonNull CameraCaptureSession cameraCaptureSession) {

            Log.e(LOG_TAG, "onConfigureFailed");
        }
    };

    public Camera2ManagerImpl(@NonNull Activity activity, @NonNull TextureView textureView,
                              @NonNull CameraCallback cameraCallback, @NonNull Mode mode) {
        super(activity, textureView, cameraCallback, mode);
        if (DEBUG) {
            Log.d(LOG_TAG, "Camera2ManagerImpl");
        }

        mCameraManager = (CameraManager) activity.getSystemService(Context.CAMERA_SERVICE);
    }

    @Override
    public void onImageAvailable(@NonNull ImageReader reader) {
        if (TRACE) {
            Log.d(LOG_TAG, "onImageAvailable");
        }

        try (Image image = reader.acquireLatestImage()) {
            if (image == null) {
                return;
            }

            // Limit the number of frames to analyze.
            final long now = System.currentTimeMillis();
            if ((now - mLastImageTime) < MIN_FRAME_DELAY) {

                return;
            }
            mLastImageTime = now;

            Image.Plane[] planes = image.getPlanes();
            int width = image.getWidth();
            int height = image.getHeight();
            if (planes.length == 3) {
                ByteBuffer yBuffer = planes[0].getBuffer();

                int yStride = planes[0].getRowStride();
                int ySize = yBuffer.remaining();

                if (TRACE) {
                    Log.e(LOG_TAG, "W=" + width + " H=" + height + " ySize=" + ySize + " yStride=" + yStride);
                }
                final byte[] data = new byte[ySize];

                yBuffer.get(data, 0, ySize);

                //noinspection SuspiciousNameCombination
                mCameraCallback.onPicture(data, yStride, height);

            } else if (planes.length == 1) {
                ByteBuffer buffer = planes[0].getBuffer();
                final byte[] data = new byte[buffer.remaining()];
                buffer.get(data);

                mCameraCallback.onPicture(data, width, height);
            }

        } catch (OutOfMemoryError exception) {
            Log.e(LOG_TAG, "Not enough memory: " + exception);
        }
    }

    /**
     * Sets up member variables related to camera.
     *
     * @param width          The width of available size for camera preview
     * @param height         The height of available size for camera preview
     * @param selectedFacing The camera facing direction
     */
    @SuppressWarnings("SuspiciousNameCombination")
    private boolean chooseCamera(int width, int height, int selectedFacing) {
        if (DEBUG) {
            Log.d(LOG_TAG, "chooseCamera width=" + width + " height=" + height + " selectedFacing=" + selectedFacing);
        }

        try {
            for (String cameraId : mCameraManager.getCameraIdList()) {
                CameraCharacteristics cameraCharacteristics = mCameraManager.getCameraCharacteristics(cameraId);

                Integer facing = cameraCharacteristics.get(CameraCharacteristics.LENS_FACING);
                if (facing != null && facing != selectedFacing) {
                    continue;
                }

                // Get an FPS range that is the slowest we can get.
                Range<Integer>[] fpsRange = cameraCharacteristics.get(CameraCharacteristics.CONTROL_AE_AVAILABLE_TARGET_FPS_RANGES);
                if (fpsRange != null) {
                    mFpsRange = null;
                    for (Range<Integer> range : fpsRange) {
                        if (mFpsRange == null || range.getLower() < mFpsRange.getLower()
                                || (range.getLower().equals(mFpsRange.getLower()) && range.getUpper() < mFpsRange.getUpper())) {
                            mFpsRange = range;
                        }
                    }
                }

                StreamConfigurationMap map = cameraCharacteristics.get(CameraCharacteristics.SCALER_STREAM_CONFIGURATION_MAP);
                if (map == null) {
                    continue;
                }

                // Choose the size according to the mode: we are using YUV for QR-code scanner and JPG for photos.
                final int imageFormat = (mMode == Mode.QRCODE) ? ImageFormat.YUV_420_888 : ImageFormat.JPEG;
                final Size[] sizes = getSizes(map, imageFormat);
                if (sizes.length == 0) {
                    continue;
                }

                // Find out if we need to swap dimension to get the preview size relative to sensor
                // coordinate.
                final Display display = mActivity.getWindowManager().getDefaultDisplay();
                int displayRotation = display.getRotation();
                final Integer orientation = cameraCharacteristics.get(CameraCharacteristics.SENSOR_ORIENTATION);
                mSensorOrientation = orientation == null ? 0 : orientation;
                mCameraOrientation = mSensorOrientation;
                boolean swappedDimensions = false;
                switch (displayRotation) {
                    case Surface.ROTATION_0:
                    case Surface.ROTATION_180:
                        if (mSensorOrientation == 90 || mSensorOrientation == 270) {
                            swappedDimensions = true;
                        }
                        break;
                    case Surface.ROTATION_90:
                    case Surface.ROTATION_270:
                        if (mSensorOrientation == 0 || mSensorOrientation == 180) {
                            swappedDimensions = true;
                        }
                        break;
                    default:
                        Log.e(LOG_TAG, "Display rotation is invalid: " + displayRotation);
                }

                int rotatedPreviewWidth = width;
                int rotatedPreviewHeight = height;
                int maxPreviewWidth = mScreenResolution.x;
                int maxPreviewHeight = mScreenResolution.y;

                if (swappedDimensions) {
                    rotatedPreviewWidth = height;
                    rotatedPreviewHeight = width;
                    maxPreviewWidth = mScreenResolution.y;
                    maxPreviewHeight = mScreenResolution.x;
                }

                if (maxPreviewWidth > MAX_PREVIEW_WIDTH) {
                    maxPreviewWidth = MAX_PREVIEW_WIDTH;
                }

                if (maxPreviewHeight > MAX_PREVIEW_HEIGHT) {
                    maxPreviewHeight = MAX_PREVIEW_HEIGHT;
                }

                Size largest = findPreviewSize(sizes, width, height, null);
                if (mMode == Mode.QRCODE) {

                    mPreviewSize = chooseOptimalSize(getSizes(map.getOutputSizes(SurfaceTexture.class)),
                            rotatedPreviewWidth, rotatedPreviewHeight, maxPreviewWidth,
                            maxPreviewHeight, largest);
                    largest = mPreviewSize;
                } else {
                    // Danger, W.R.! Attempting to use too large a preview size could  exceed the camera
                    // bus' bandwidth limitation, resulting in gorgeous previews but the storage of
                    // garbage capture data.
                    mPreviewSize = chooseOptimalSize(getSizes(map.getOutputSizes(SurfaceTexture.class)),
                            rotatedPreviewWidth, rotatedPreviewHeight, maxPreviewWidth,
                            maxPreviewHeight, largest);
                }

                mImageReader = ImageReader.newInstance(largest.width, largest.height, imageFormat, 2);
                mImageReader.setOnImageAvailableListener(this, mCameraHandler);

                if (DEBUG) {
                    Log.e(LOG_TAG, "Preview size=" + mPreviewSize);
                }
                mCameraFacing = facing != null && facing == CameraMetadata.LENS_FACING_FRONT;

                mCameraResolution = new Size(mPreviewSize.width, mPreviewSize.height);

                // Check if the flash is supported.
                Boolean available = cameraCharacteristics.get(CameraCharacteristics.FLASH_INFO_AVAILABLE);
                mFlashSupported = available != null && available;

                mActiveArraySize = cameraCharacteristics.get(CameraCharacteristics.SENSOR_INFO_ACTIVE_ARRAY_SIZE);
                mMaximumZoomLevel = cameraCharacteristics.get(CameraCharacteristics.SCALER_AVAILABLE_MAX_DIGITAL_ZOOM);
                mAutoFocusModes = cameraCharacteristics.get(CameraCharacteristics.CONTROL_AF_AVAILABLE_MODES);
                mAutoExposureModes = cameraCharacteristics.get(CameraCharacteristics.CONTROL_AE_AVAILABLE_MODES);

                mCameraId = cameraId;
                return true;
            }
        } catch (CameraAccessException | IllegalArgumentException ex) {
            // Ignore this error.
            if (DEBUG) {
                Log.d(LOG_TAG, "Camera exception: " + ex);
            }

            // Possible transient errors: retry to open the camera a little bit later.
            mCameraId = null;
            mOpenRetryCount++;
            return mOpenRetryCount >= MAX_OPEN_RETRY;

        } catch (NullPointerException e) {
            // Currently an NPE is thrown when the Camera2API is used but not supported on the
            // device this code runs.
        }

        mCameraId = null;
        return true;
    }

    protected void openInternal() {
        if (DEBUG) {
            Log.d(LOG_TAG, "openInternal");
        }

        checkIsOnCameraThread();

        if (mCamera != null) {
            mCamera.close();
            mCamera = null;
        }

        if (mImageReader != null) {
            mImageReader.close();
            mImageReader = null;
        }

        // If we have a very very slow camera opening, it is possible that the close() was called before we proceed.
        // In that case, don't try to open the camera, the closeInternal() is queued and will do the necessary clearnup.
        if (mState == State.STOPPING) {
            return;
        }

        int facing = mAskedCameraFacing ? CameraCharacteristics.LENS_FACING_BACK : CameraCharacteristics.LENS_FACING_FRONT;
        if (!chooseCamera(mTextureView.getWidth(), mTextureView.getHeight(), facing)) {

            // Retry opening the camera in 250ms (up to 2 times).
            mCameraHandler.postDelayed(this::openInternal, 250);
            return;
        }

        if (mCameraId == null) {

            mState = State.ERROR;
            mCameraCallback.onCameraError(ErrorCode.NO_CAMERA);
            return;
        }

        if (ContextCompat.checkSelfPermission(mActivity, Manifest.permission.CAMERA) != PackageManager.PERMISSION_GRANTED) {

            mState = State.ERROR;
            mCameraCallback.onCameraError(ErrorCode.NO_PERMISSION);
            return;
        }

        mCameraState = CameraState.STATE_PREVIEW;
        try {
            mCameraManager.openCamera(mCameraId, mStateCallback, mCameraHandler);

        } catch (CameraAccessException ex) {
            onCameraAccessException(ex);

        } catch (SecurityException ex) {
            mState = State.ERROR;
            mCameraCallback.onCameraError(ErrorCode.NO_PERMISSION);

        } catch (Exception exception) {
            mState = State.ERROR;
            mCameraCallback.onCameraError(ErrorCode.CAMERA_IN_USE);
        }
    }

    @Override
    protected void closeInternal() {
        if (DEBUG) {
            Log.d(LOG_TAG, "closeInternal");
        }

        checkIsOnCameraThread();

        mOrientationListener.disable();

        if (mCaptureSession != null) {
            try {
                mCaptureSession.close();
            } catch (Exception ex) {
                // Don't rely on Android documentation: the close can raise an exception.  It is safe to ignore it.
                // android.hardware.camera2.CameraAccessException: CAMERA_ERROR (3): The camera device has encountered a serious error
                // at android.hardware.camera2.impl.CameraDeviceImpl.checkIfCameraClosedOrInError(CameraDeviceImpl.java:2563)
                // at android.hardware.camera2.impl.CameraDeviceImpl.stopRepeating(CameraDeviceImpl.java:1140)
                // at android.hardware.camera2.impl.CameraCaptureSessionImpl.close(CameraCaptureSessionImpl.java:527)
                // at org.twinlife.twinme.utils.camera.Camera2ManagerImpl.closeInternal(Camera2ManagerImpl.java:571)
                Log.d(LOG_TAG, "exception", ex);
            }
            mCaptureSession = null;
        }

        if (mPreviewSurface != null) {
            mPreviewSurface.release();
            mPreviewSurface = null;
        }

        if (mCamera != null) {
            mCamera.close();
            mCamera = null;
            // The camera thread is released by onClose().
        } else {
            // Release the camera thread: it will stop when it is no longer in use.
            mCameraThread.release();
        }

        if (mImageReader != null) {
            mImageReader.close();
            mImageReader = null;
        }

        mOpenRetryCount = 0;
        mSurfaceTexture = null;
    }

    @Override
    protected void stopPreview() {
        if (DEBUG) {
            Log.d(LOG_TAG, "stopPreview");
        }

        CameraCaptureSession captureSession = mCaptureSession;
        if (captureSession != null) {
            try {
                captureSession.abortCaptures();
                captureSession.stopRepeating();
            } catch (CameraAccessException ex) {
                onCameraAccessException(ex);
            } catch (IllegalStateException ex) {
                if (DEBUG) {
                    Log.d(LOG_TAG, "camera session is closed");
                }
            }
        }
    }

    @Override
    protected void takePictureInternal() {
        if (DEBUG) {
            Log.d(LOG_TAG, "takePictureInternal");
        }

        checkIsOnCameraThread();

        // Check and switch to the WAITING_PICTURE state.
        synchronized (this) {
            if (mState != State.READY || mCamera == null || mCaptureSession == null) {

                return;
            }

            mState = State.WAITING_PICTURE;
        }

        try {
            // This is how to tell the camera to lock focus.
            mPreviewRequestBuilder.set(CaptureRequest.CONTROL_AF_TRIGGER, CameraMetadata.CONTROL_AF_TRIGGER_START);
            // Tell #mCaptureCallback to wait for the lock.
            mCameraState = CameraState.STATE_WAITING_LOCK;
            mCaptureSession.capture(mPreviewRequestBuilder.build(), mCaptureCallback, mCameraHandler);

        } catch (CameraAccessException ex) {
            onCameraAccessException(ex);

        } catch (RuntimeException ex) {
            Log.d(LOG_TAG, "exception", ex);
        }
    }

    @Override
    protected void startRecordVideoInternal() {
        if (DEBUG) {
            Log.d(LOG_TAG, "startRecordVideoInternal");
        }
    }

    @Override
    protected void stopRecordVideoInternal() {
        if (DEBUG) {
            Log.d(LOG_TAG, "stopRecordVideoInternal");
        }
    }

    /**
     * Creates a new {@link CameraCaptureSession} for camera preview.
     */
    private void createCameraPreviewSession(@NonNull CameraDevice camera) {

        synchronized (this) {
            // closeInternal() was called: the camera.close() was called.
            if (mSurfaceTexture == null) {
                return;
            }

            mCamera = camera;

            // We are stopping but closeInternal() was not yet called: we must leave with mCamera set so that it will be closed.
            if (mState != State.STARTING) {
                return;
            }
        }

        try {
            SurfaceTexture texture = mTextureView.getSurfaceTexture();

            // If there is no texture, the view was deleted and the camera manager is going to be closed.
            if (texture == null || mPreviewSize == null || mImageReader == null) {

                return;
            }

            // We configure the size of default buffer to be the size of camera preview we want.
            texture.setDefaultBufferSize(mPreviewSize.width, mPreviewSize.height);

            // This is the output Surface we need to start preview.
            mPreviewSurface = new Surface(texture);

            setSizes();

            if (mMode == Mode.PHOTO) {
                mOrientationListener.enable();
            }

            // We set up a CaptureRequest.Builder with the output Surface.
            mPreviewRequestBuilder = mCamera.createCaptureRequest(CameraDevice.TEMPLATE_PREVIEW);
            mPreviewRequestBuilder.addTarget(mPreviewSurface);
            if (mMode == Mode.QRCODE) {
                mPreviewRequestBuilder.addTarget(mImageReader.getSurface());
                setZoom(mPreviewRequestBuilder, 1.5f);
                mPreviewRequestBuilder.set(CaptureRequest.CONTROL_AF_TRIGGER, CameraMetadata.CONTROL_AF_TRIGGER_START);
                if (mFpsRange != null) {
                    mPreviewRequestBuilder.set(CaptureRequest.CONTROL_AE_TARGET_FPS_RANGE, mFpsRange);
                }
                // mPreviewRequestBuilder.set(CaptureRequest.CONTROL_AWB_MODE, CameraMetadata.CONTROL_AWB_MODE_AUTO);
            }

            if (mFlashSupported) {
                mPreviewRequestBuilder.set(CaptureRequest.FLASH_MODE, CameraMetadata.FLASH_MODE_OFF);
                if (mMode != Mode.QRCODE && hasMode(mAutoExposureModes, CameraMetadata.CONTROL_AE_MODE_ON_AUTO_FLASH)) {
                    mPreviewRequestBuilder.set(CaptureRequest.CONTROL_AE_MODE, CameraMetadata.CONTROL_AE_MODE_ON_AUTO_FLASH);
                }
            }

            List<Surface> surfaceList = new ArrayList<>();
            surfaceList.add(mPreviewSurface);
            surfaceList.add(mImageReader.getSurface());

            // Here, we create a CameraCaptureSession for camera preview.
            camera.createCaptureSession(surfaceList, mCaptureStateCallback, null);

            // Change to READY state and call the onCameraReady() callback to let the caller setup its preview.
            // The onCameraReady() is called from the Camera Thread and it must do all the necessary setup
            // so that the view is ready to accept a frame.  It must not do this setup from the main UI thread
            // because it may receive a frame while it is not fully initialized!
            synchronized (this) {
                // Be careful: it is possible that close() is called, in that case we should not change to the READY state.
                if (mState == State.STOPPING) {
                    return;
                }

                mState = State.READY;
            }
            mCameraCallback.onCameraReady();

        } catch (CameraAccessException ex) {
            onCameraAccessException(ex);

        } catch (RuntimeException ex) {
            Log.d(LOG_TAG, "exception", ex);
        }
    }

    /**
     * Run the precapture sequence for capturing a still image. This method should be called when
     * we get a response in {@link #mCaptureCallback} from {@link #takePictureInternal()}.
     */
    private void runPrecaptureSequence() {
        if (DEBUG) {
            Log.d(LOG_TAG, "runPrecaptureSequence");
        }

        checkIsOnCameraThread();

        synchronized (this) {
            if (mCamera == null || mState == State.STOPPING || mCaptureSession == null) {
                return;
            }
        }

        try {
            // This is how to tell the camera to trigger.
            mPreviewRequestBuilder.set(CaptureRequest.CONTROL_AE_PRECAPTURE_TRIGGER, CaptureRequest.CONTROL_AE_PRECAPTURE_TRIGGER_START);
            CaptureRequest captureRequest = mPreviewRequestBuilder.build();

            mPreviewRequestBuilder.set(CaptureRequest.CONTROL_AE_PRECAPTURE_TRIGGER, null);

            // Tell #mCaptureCallback to wait for the precapture sequence to be set.
            mCameraState = CameraState.STATE_WAITING_PRECAPTURE;
            mCaptureSession.capture(captureRequest, mCaptureCallback, mCameraHandler);

        } catch (CameraAccessException ex) {
            onCameraAccessException(ex);

        } catch (RuntimeException ex) {
            Log.d(LOG_TAG, "exception", ex);
        }
    }

    /**
     * Capture a still picture. This method should be called when we get a response in
     * {@link #mCaptureCallback} from both {@link #takePictureInternal()}.
     */
    private void captureStillPicture() {
        if (DEBUG) {
            Log.d(LOG_TAG, "takePictureInternal");
        }

        checkIsOnCameraThread();

        final CameraCaptureSession cameraCaptureSession;
        synchronized (this) {
            cameraCaptureSession = mCaptureSession;
            if (mCamera == null || mState == State.STOPPING || cameraCaptureSession == null) {
                return;
            }
        }

        try {
            // This is the CaptureRequest.Builder that we use to take a picture.
            final CaptureRequest.Builder captureBuilder = mCamera.createCaptureRequest(CameraDevice.TEMPLATE_STILL_CAPTURE);
            captureBuilder.addTarget(mImageReader.getSurface());

            if (hasMode(mAutoFocusModes, CaptureRequest.CONTROL_AF_MODE_CONTINUOUS_PICTURE)) {
                captureBuilder.set(CaptureRequest.CONTROL_AF_MODE, CaptureRequest.CONTROL_AF_MODE_CONTINUOUS_PICTURE);

            } else if (hasMode(mAutoFocusModes, CaptureRequest.CONTROL_AF_MODE_AUTO)) {
                captureBuilder.set(CaptureRequest.CONTROL_AF_MODE, CaptureRequest.CONTROL_AF_MODE_AUTO);
            }

            setAutoFlash(captureBuilder);

            if (DEBUG) {
                Log.e(LOG_TAG, "JPEG orientation=" + mCameraOrientation);
            }
            captureBuilder.set(CaptureRequest.JPEG_ORIENTATION, mCameraOrientation);

            CameraCaptureSession.CaptureCallback CaptureCallback
                    = new CameraCaptureSession.CaptureCallback() {

                @Override
                public void onCaptureCompleted(@NonNull CameraCaptureSession session,
                                               @NonNull CaptureRequest request,
                                               @NonNull TotalCaptureResult result) {
                    unlockFocus();
                }
            };

            cameraCaptureSession.stopRepeating();
            cameraCaptureSession.abortCaptures();
            cameraCaptureSession.capture(captureBuilder.build(), CaptureCallback, mCameraHandler);
        } catch (CameraAccessException ex) {
            onCameraAccessException(ex);

        } catch (Exception e) {
            Log.e(LOG_TAG, "Error: " + e);
        }
    }

    /**
     * Unlock the focus. This method should be called when still image capture sequence is
     * finished.
     */
    private void unlockFocus() {
        if (DEBUG) {
            Log.d(LOG_TAG, "unlockFocus");
        }

        checkIsOnCameraThread();

        synchronized (this) {
            if (mCamera == null || mState == State.STOPPING || mCaptureSession == null) {
                return;
            }

            if (mState == State.WAITING_PICTURE) {
                mState = State.READY;
            }
        }

        try {
            // Reset the auto-focus trigger
            mPreviewRequestBuilder.set(CaptureRequest.CONTROL_AF_TRIGGER, CameraMetadata.CONTROL_AF_TRIGGER_CANCEL);
            setAutoFlash(mPreviewRequestBuilder);
            mCaptureSession.capture(mPreviewRequestBuilder.build(), mCaptureCallback, mCameraHandler);

            // After this, the camera will go back to the normal state of preview.
            mCameraState = CameraState.STATE_PREVIEW;
            mCaptureSession.setRepeatingRequest(mPreviewRequest, mCaptureCallback, mCameraHandler);

        } catch (CameraAccessException ex) {
            onCameraAccessException(ex);

        } catch (RuntimeException ex) {
            Log.d(LOG_TAG, "exception", ex);
        }
    }

    protected void restartAutoFocus(boolean cancel) {
        if (DEBUG) {
            Log.e(LOG_TAG, "restartAutoFocus cancel=" + cancel);
        }

        checkIsOnCameraThread();

        synchronized (this) {
            if (mCaptureSession == null || mState == State.STOPPING) {

                return;
            }
        }

        try {
            mLastAutoFocusTime = System.currentTimeMillis();

            // Cancel the auto-focus trigger.  Different phones, different behaviors: cancel only if the auto-focus failed.
            if (cancel) {
                mPreviewRequestBuilder.set(CaptureRequest.CONTROL_AF_TRIGGER, CameraMetadata.CONTROL_AF_TRIGGER_CANCEL);
                mCaptureSession.capture(mPreviewRequestBuilder.build(), mCaptureCallback, mCameraHandler);
            }

            mPreviewRequestBuilder.set(CaptureRequest.CONTROL_AF_TRIGGER, CameraMetadata.CONTROL_AF_TRIGGER_START);
            CaptureRequest captureRequest = mPreviewRequestBuilder.build();

            // Reset the auto-focus trigger
            mPreviewRequestBuilder.set(CaptureRequest.CONTROL_AF_TRIGGER, null);

            mCaptureSession.capture(captureRequest, mCaptureCallback, mCameraHandler);

        } catch (CameraAccessException ex) {
            onCameraAccessException(ex);

        } catch (RuntimeException ex) {
            Log.d(LOG_TAG, "exception", ex);
        }
    }

    private void onCameraAccessException(@NonNull CameraAccessException ex) {
        if (DEBUG) {
            Log.d(LOG_TAG, "onCameraAccessException ex=" + ex);
        }

        synchronized (this) {
            if (mState == State.STOPPING) {

                return;
            }
            mState = State.ERROR;
        }

        switch (ex.getReason()) {
            case CameraAccessException.CAMERA_IN_USE:
                mCameraCallback.onCameraError(ErrorCode.CAMERA_IN_USE);
                break;

            case CameraAccessException.CAMERA_DISCONNECTED:
            case CameraAccessException.CAMERA_DISABLED:
            case CameraAccessException.MAX_CAMERAS_IN_USE:
                mCameraCallback.onCameraError(ErrorCode.NO_CAMERA);
                break;

            case CameraAccessException.CAMERA_ERROR:
                mCameraCallback.onCameraError(ErrorCode.CAMERA_ERROR);
                break;
        }
    }

    private void setZoom(@NonNull CaptureRequest.Builder requestBuilder, final float zoom) {
        if (DEBUG) {
            Log.d(LOG_TAG, "setZoom zoom=" + zoom);
        }

        if (mMaximumZoomLevel == null || mActiveArraySize == null) {
            return;
        }

        final float newZoom = MathUtils.clamp(zoom, 1.0f, mMaximumZoomLevel);

        final int centerX = mActiveArraySize.width() / 2;
        final int centerY = mActiveArraySize.height() / 2;
        final int deltaX = (int) (mActiveArraySize.width() / newZoom) / 2;
        final int deltaY = (int) (mActiveArraySize.height() / newZoom) / 2;

        Rect zoomArea = new Rect(centerX - deltaX, centerY - deltaY, centerX + deltaX, centerY + deltaY);

        requestBuilder.set(CaptureRequest.SCALER_CROP_REGION, zoomArea);
    }

    private void setAutoFlash(@NonNull CaptureRequest.Builder requestBuilder) {

        if (mFlashSupported) {
            requestBuilder.set(CaptureRequest.CONTROL_AE_MODE, CaptureRequest.CONTROL_AE_MODE_ON_AUTO_FLASH);
        }
    }

    @Override
    protected void onOrientationChanged(int degrees) {
        if (DEBUG) {
            Log.d(LOG_TAG, "onOrientationChanged degrees=" + degrees);
        }

        if (mCameraId == null || mCameraResolution == null || mPreviewSize == null || mCaptureSession == null) {

            return;
        }

        int rotation;
        if (mCameraFacing) {
            rotation = (mSensorOrientation + degrees) % 360;
            // compensate the mirror
            mCameraOrientation = (360 - rotation) % 360;
        } else { // back-facing
            rotation = (mSensorOrientation - degrees + 360) % 360;
            mCameraOrientation = rotation;
            Log.e(LOG_TAG, "onOrientation " + degrees + " sensor=" + mSensorOrientation + " orient=" + mCameraOrientation);
        }

        try {
            mPreviewRequestBuilder.set(CaptureRequest.JPEG_ORIENTATION, rotation);

            mPreviewRequest = mPreviewRequestBuilder.build();
            mCaptureSession.setRepeatingRequest(mPreviewRequest, mCaptureCallback, mCameraHandler);

        } catch (CameraAccessException ex) {
            onCameraAccessException(ex);

        } catch (RuntimeException ex) {
            Log.d(LOG_TAG, "exception", ex);
        }
    }

    @Override
    protected void setTorchInternal() {
        if (DEBUG) {
            Log.d(LOG_TAG, "setTorchInternal currentFlashMode=" + mCurrentFlashMode);
        }

        checkIsOnCameraThread();

        final CameraCaptureSession cameraCaptureSession = mCaptureSession;
        if (mCamera == null || !isOpened() || cameraCaptureSession == null || !mFlashSupported) {

            return;
        }

        try {
            switch (mCurrentFlashMode) {
                case ON:
                    mPreviewRequestBuilder.set(CaptureRequest.FLASH_MODE, CaptureRequest.FLASH_MODE_TORCH);
                    if (hasMode(mAutoExposureModes, CameraMetadata.CONTROL_AE_MODE_ON)) {
                        mPreviewRequestBuilder.set(CaptureRequest.CONTROL_AE_MODE, CameraMetadata.CONTROL_AE_MODE_ON);
                    }
                    break;

                case OFF:
                    mPreviewRequestBuilder.set(CaptureRequest.FLASH_MODE, CaptureRequest.FLASH_MODE_OFF);
                    if (hasMode(mAutoExposureModes, CameraMetadata.CONTROL_AE_MODE_ON_AUTO_FLASH)) {
                        mPreviewRequestBuilder.set(CaptureRequest.CONTROL_AE_MODE, CameraMetadata.CONTROL_AE_MODE_ON_AUTO_FLASH);
                    }
                    break;

                case SINGLE:
                    mPreviewRequestBuilder.set(CaptureRequest.FLASH_MODE, CaptureRequest.FLASH_MODE_SINGLE);
                    if (hasMode(mAutoExposureModes, CameraMetadata.CONTROL_AE_MODE_ON_AUTO_FLASH_REDEYE)) {
                        mPreviewRequestBuilder.set(CaptureRequest.CONTROL_AE_MODE, CameraMetadata.CONTROL_AE_MODE_ON_AUTO_FLASH_REDEYE);
                    }
                    break;
            }

            mPreviewRequest = mPreviewRequestBuilder.build();
            cameraCaptureSession.setRepeatingRequest(mPreviewRequest, mCaptureCallback, mCameraHandler);
        } catch (CameraAccessException ex) {
            onCameraAccessException(ex);

        } catch (RuntimeException ex) {
            Log.d(LOG_TAG, "exception", ex);
        }
    }

    @Override
    protected void setZoomInternal() {
        if (DEBUG) {
            Log.d(LOG_TAG, "setZoomInternal zoom=" + mCurrentZoom);
        }
    }

    private boolean hasMode(@Nullable int[] availableModes, int mode) {

        if (availableModes != null) {
            for (int availableMode : availableModes) {
                if (mode == availableMode) {
                    return true;
                }
            }
        }
        return false;
    }

    @NonNull
    private static Size[] getSizes(@NonNull StreamConfigurationMap map, int format) {

        return getSizes(map.getOutputSizes(format));
    }

    @NonNull
    private static Size[] getSizes(@Nullable android.util.Size[] sizes) {

        if (sizes == null) {
            return new Size[] {};
        }

        Size[] result = new Size[sizes.length];
        for (int i = 0; i < result.length; i++) {
            android.util.Size size = sizes[i];

            result[i] = new Size(size.getWidth(), size.getHeight());
        }
        return result;
    }

    /**
     * Compares two {@code Size}s based on their areas.
     */

    @NonNull
    private static String getErrorDescription(int errorCode) {
        switch (errorCode) {
            case CameraDevice.StateCallback.ERROR_CAMERA_DEVICE:
                return "Camera device has encountered a fatal error.";
            case CameraDevice.StateCallback.ERROR_CAMERA_DISABLED:
                return "Camera device could not be opened due to a device policy.";
            case CameraDevice.StateCallback.ERROR_CAMERA_IN_USE:
                return "Camera device is in use already.";
            case CameraDevice.StateCallback.ERROR_CAMERA_SERVICE:
                return "Camera service has encountered a fatal error.";
            case CameraDevice.StateCallback.ERROR_MAX_CAMERAS_IN_USE:
                return "Camera device could not be opened because"
                        + " there are too many other open camera devices.";
            default:
                return "Unknown camera error: " + errorCode;
        }
    }
}
